## 01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？



## 02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？

> 代码质量的评价有很强的主观性,并不能通过单一的维度去评价一段代码的好坏。

### 评价标准

- 可维护性（maintainability）

  > 如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。

- 可读性（readability）

  > 看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰

- 可扩展性（extensibility）

- 灵活性（flexibility）
- 简洁性（simplicity）
- 可复用性（reusability）
- 可测试性（testability）



## 03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

### 面向对象

- 面向对象的四大特性：封装、抽象、继承、多态
- 面向对象编程与面向过程编程的区别和联系
- 面向对象分析、面向对象设计、面向对象编程
- 接口和抽象类的区别以及各自的应用场景
- 基于接口而非实现编程的设计思想
- 多用组合少用继承的设计思想
- 面向过程的贫血模型和面向对象的充血模型

### 设计原则

- SOLID 原则 -SRP 单一职责原则
- SOLID 原则 -OCP 开闭原则
- SOLID 原则 -LSP 里式替换原则
- SOLID 原则 -ISP 接口隔离原则
- SOLID 原则 -DIP 依赖倒置原则
- DRY 原则、KISS 原则、YAGNI 原则、LOD 法则

### 设计模式

经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。

1. 创建型
2. 结构型
3. 行为型

### 编程规范

### 代码重构

![img](pic\02.png)

## 04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？

- OOP Object Oriented Programming
  - 一种编程范式或编程风格
  - 以类或对象作为组织代码的基本单元
  - 封装、（抽象）、继承、多态
- OOPL Object Oriented Programming Language
- OOA Object Oriented Analysis
- OOD Object Oriented Design

> UML（Unified Model Language）：统一建模语言
>
> 它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等。
>
> 类之间的关系：泛化、实现、关联、聚合、组合、依赖

## 05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

- 封装（Encapsulation）

  - 信息隐藏或者数据访问保护
  - 类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性（调用者就不需要了解太多背后的业务细节，用错的概率就减少很多）
  - 用户范围权限（Java）

  <img src="pic\05.png" alt="image-20200805222756790" style="zoom:50%;" />

- 继承（Inheritance）

  - extends，单继承和多继承
  - 优点：继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类
  - 缺点：过度使用继承，子类和父类高度耦合，修改父类的代码，会直接影响到子类，所以，继承这个特性也是一个非常有争议的特性。
  - 多继承会有钻石问题(菱形继承)，考虑到这种二义性问题，Java 不支持多重继承

- 多态（Polymorphism）

  - 子类可以替换父类

    - 继承加方法重写

    - 接口

    - duck-typing 

      - python有，没有任何关系，但是只要它们都有定义了相同的方法

      ```python
      
      class Logger:
          def record(self):
              print(“I write a log into file.”)
              
      class DB:
          def record(self):
              print(“I insert data into db. ”)
              
      def test(recorder):
          recorder.record()
      
      def demo():
          logger = Logger()
          db = DB()
          test(logger)
          test(db)
      ```

  - 优点：提高了代码的可扩展性、复用性

- 抽象（Abstraction）

  - interface
  - abstract
  - 调用者只需要了解接口类暴露了哪些方法，不需要去查看类里的具体实现逻辑。
  - 保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义
  - 不属于面向对象三大特性

## 06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？

- 面向过程编程
  - 面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。
- 面向对象编程相比面向过程编程有哪些优势？
  - OOP 更加能够应对大规模复杂程序的开发
  - OOP 风格的代码更易复用、易扩展、易维护
  - OOP 语言更加人性化、更加高级、更加智能



## 07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？

- 编程风格
  - 面向过程
  - 面向对象
  - 函数式

- 哪些代码设计看似是面向对象，实际是面向过程的？
  - 滥用 getter、setter 方法
    - 直接用 IDE 或者 Lombok 插件自动生成所有属性的 getter、setter 方法
    - 相当于弱化`封装`
    - getter可能返回的是容器对象，那么外部自然可以对该对象进行其他的操作，导致内部相关数据不一致
    - 可使用`Collections.unmodifiableList() `方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，避免返回对象被外部修改
    - 通过上述方法，虽然我们没法修改容器的数据，但我们仍然可以修改容器中每个对象的数据，需要其他方法来制止
  - 滥用全局变量和全局方法
    - 增加代码的编译时间，当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，影响单元测试的效率
      - 改进：
        1. 将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。
        2. 并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中
  - 定义数据和方法分离的类
    - （基于贫血模型的开发模式）MVC中，会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。



- 面向过程常用在？
  - 微小程序开发（比赛）
  - 数据处理
  - shell、scala 脚本

## 08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？

> C++ 支持抽象类，不支持接口
>
> Python 既不支持抽象类，也不支持接口



`public abstract class XXX{}` & `public interface XXX{}`

- 抽象类和接口的区别
  - 抽象类不允许被实例化，只能被继承。接口也不允许实例化，只能被实现。
  - 抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现，不包含代码实现的方法叫作抽象方法。接口不能包含属性（也就是成员变量），只能声明方法，方法不能包含代码实现。
  - 子类继承抽象类，必须实现抽象类中的所有抽象方法。类实现接口的时候，必须实现接口中声明的所有方法。



> 抽象类 is-a
>
> 接口 has-a

- 抽象类的作用
  
- 代码复用
  
- 接口的作用
  
- 多态
  
- Java中，使用普通类来模拟接口？

  ```java
  public class MockInteface {
    protected MockInteface() {}  // 防止该类被实例化
    public void funcA() {
      throw new MethodUnSupportedException(); //强制子类重写方法
    }
  }
  ```

- python中，如何实现接口？ **TODO**

## 09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？

- 基于接口而非实现编程
  - 函数的命名不能暴露任何实现细节
  - 封装具体的实现细节
  - 为实现类定义抽象的接口



> 很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。
>
> 将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中.（抽取出公共的部分）



- 将接口和实现相分离，封装不稳定的实现，暴露稳定的接口-
- 上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。



> 如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。



- 第8行通过多态来使用接口，但如果修改业务后，还是需要修改很多类似第 8 行那样的代码，怎么办？（工厂类）

```java
// ImageStore的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...;//处理图片，并封装为Image对象
    ImageStore imageStore = new PrivateImageStore(/*省略构造函数*/);
    imagestore.upload(image, BUCKET_NAME);
  }
}
```

