### 多线程的出现是要解决什么问题的?

CPU、内存、I/O 设备的速度是有极大差异

- CPU 增加了缓存，均衡CPU与内存的速度差异，导致 `可见性`问题

- **操作系统增加了进程、线程，以分时复用 CPU，均衡 CPU 与 I/O 设备的速度差异，充分利用CPU资源**。导致 `原子性`问题
  - 采用多线程的方式去同时完成几件事情而不互相干扰
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用，导致 `有序性`问题

### 多线程的优缺点？

优点

- 提高资源利用率（在IO的时候，让线程去做其他事情）
- 提高响应速度（异步）

缺点

- 多个线程切换，反而性能下降
- 死锁
- 等待使用共享资源时造成的性能下降
- 开发成本高

### 进程是什么？

- 资源分配的最小单位
- 是线程的容器
- 是程序的实体

### 线程是什么？

- 任务调度和执行的最小单位（分配处理器时间的基本单元）
- 是进程中的实际运作单位

### 进程与线程的区别与联系？

联系：

- 进程是线程的容器

- 没有线程的进程可以看做是单线程的

- 进程中至少有一条线程（主线程）

  

<img src="pic\1629488-20190622115300479-2129397443.png" alt="进程" style="zoom:30%;" />

区别：

- 根本区别：
  - 进程是操作系统资源分配的基本单位
  - 线程是任务调度和执行的基本单位
- 开销：
  - 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销
  - 线程可以看做轻量级的进程，同一类线程共享代码和数据空间，线程之间切换的开销小
- 环境：
  - 在操作系统中能同时运行多个进程（程序）
  - 在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）
- 内存：
  - 系统会为每个进程分配不同的内存空间
  - 对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**
- 影响：
  - 一个进程崩溃后，在保护模式下不会对其他进程产生影响
  - 一个线程崩溃可能会导致整个进程都崩溃（Java程序中某个线程读数据出错，整个进程停止）
- 执行：
  - 进程有程序运行的入口、执行序列和程序出口
  - 线程不能独立执行，必须依存在应用程序中

### 并行与并发的区别？

并发（concurrent）：有处理多个任务的能力，不一定要同时

![img](pic\webp-concurrency.jpg)

并行(parallel)：有同时处理多个任务的能力

![parallel](pic\parallel.jpg)

**“并行”概念是“并发”概念的一个子集**

<img src="pic\v2-674f0d37fca4fac1bd2df28a2b78e633_720w.jpg" alt="img" style="zoom: 50%;" />



> 并发和并行都可以是多个线程，如果这些线程同时被多个CPU执行，就是并行，而并发时多个线程被一个CPU轮流切换执行
>
> 单核CPU同一时刻只能执行一个线程(单核多线程并不能提高运行速度)

### 导致并发问题的根源是什么？

- 可见性：CPU缓存引起

  ```java
  //线程1执行的代码
  int i = 0;
  i = 10;
   
  //线程2执行的代码
  j = i; 
  ```

  > 线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
  >
  > 在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。

- 原子性：分时复用引起

  > 一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

- 有序性：重排序引起

  > 在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序，那么可能命令的执行顺序与源码不同


### 同步和异步的区别？

同步：发送一个请求，需要等待返回，才能够发送下一个请求

异步：发送一个请求，不需要等待返回，就能够发送下一个请求

### 如何创建和运行线程？

- 继承 Thread

  ```java
  public class MyThread extends Thread {
  	public void run() {
  		print("run");
  	}
  	public static void main(String[] args) {
  		MyThread mThread1=new MyThread();
  		myThread1.start(); //运行
  	}
  }
  ```

- 实现 Runnable 

  ```java
  public class MyThread implements Runnable{
  	public static int count=20;
  	public void run() {
  		print("run");
  	}
  	public static void main(String[] args) {
  		MyThread Thread1=new MyThread();
  		Thread mThread1=new Thread(Thread1,"线程1"); 
  		mThread1.start();
  	}
  }
  ```

- FutureTask+Callable

- 通过线程池启动多线程

  - 通过Executor 的工具类

### Thread和Runnable的区别？

- .实现Runnable接口可避免多继承局限



### 查看进程和线程的方法？

windows

linux

jconsole（防火墙关闭）



### 线程运行的原理？

栈帧debug

多线程

上下文切换