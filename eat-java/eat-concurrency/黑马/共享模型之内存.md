## Java 内存模型

JMM 即 Java Memory Model，它定义了主存（静态变量、全局变量）、工作内存（局部变量）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。



JMM体现在

- 原子性 保证指令不会受到线程上下文切换的影响
- 可见性 保证指令不会受 cpu 缓存的影响
- 有序性 保证指令不会受 cpu 指令并行优化的影响



## 可见性

### 退不出的循环

```java
static boolean run = true;
public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(()->{
    while(run){
    	// ....
    }
    });
    t.start();
    
    sleep(1);
    run = false; // 线程t不会如预想的停下来
}
```

1. 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。

<img src="pic\image-20200923112916620.png" alt="image-20200923112916620" style="zoom: 67%;" />

2. 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率

<img src="pic\image-20200923112944994.png" alt="image-20200923112944994" style="zoom:67%;" />

3. 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

<img src="pic\image-20200923113014716.png" alt="image-20200923113014716" style="zoom:67%;" />

解决方法

1. volatile：用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存

2. 加 synchronize ：既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是
   synchronized 是属于重量级操作，性能相对更低
3. 加 Sys.out.prient()  todo



### 可见性 vs 原子性

可见性：保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况

原子性：保证线程之间对共享资源读写交互不会出现问题



### 两阶段终止模式

利用停止标记

```java
// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性
// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见

class TPTVolatile {
    private Thread thread;
    private volatile boolean stop = false;
    public void start(){
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if(stop) {
                	log.debug("料理后事");
                	break;
                }
                try {
                	Thread.sleep(1000);
                	log.debug("将结果保存");
                } catch (InterruptedException e){
                }
                // 执行监控操作
            }
        },"监控线程");
        
        thread.start();
   }
    
    public void stop() {
        stop = true;
        thread.interrupt();
    }
}

// 测试
TPTVolatile t = new TPTVolatile();
t.start();
Thread.sleep(3500);
log.debug("stop");
t.stop();
```

**JVM 内存监控**

单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题 **TODO**

> 饿汉式：类加载就会导致该单实例对象被创建
>
> 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建



### 同步模式之 Balking

Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回

```java
public class MonitorService {
	// 用来表示是否已经有线程已经在执行启动了
	private volatile boolean starting; //这里加了synchronized 那么volatile应该不用加
    
    public void start() {
        log.info("尝试启动监控线程...");
        synchronized (this) {
            if (starting) {
            	return;
            }
            starting = true;
        }
        // 真正启动监控线程...
    }
}
```

单例模式

```java
public final class Singleton {
    private Singleton() {
    }
    
    private static Singleton INSTANCE = null;
    
    public static synchronized Singleton getInstance() {
        if (INSTANCE != null) {
        	return INSTANCE;
    	}
        INSTANCE = new Singleton();
        return INSTANCE;
    }
}
```

