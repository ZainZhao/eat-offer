## Java 内存模型

JMM 即 Java Memory Model，它定义了主存（静态变量、全局变量）、工作内存（局部变量）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。



JMM体现在

- 原子性 保证指令不会受到线程上下文切换的影响
- 可见性 保证指令不会受 cpu 缓存的影响
- 有序性 保证指令不会受 cpu 指令并行优化的影响



## 可见性

### 退不出的循环

```java
static boolean run = true;
public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(()->{
    while(run){
    	// ....
    }
    });
    t.start();
    
    sleep(1);
    run = false; // 线程t不会如预想的停下来
}
```

1. 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。

<img src="pic\image-20200923112916620.png" alt="image-20200923112916620" style="zoom: 67%;" />

2. 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率

<img src="pic\image-20200923112944994.png" alt="image-20200923112944994" style="zoom:67%;" />

3. 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

<img src="pic\image-20200923113014716.png" alt="image-20200923113014716" style="zoom:67%;" />

解决方法

1. volatile：用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存

2. 加 synchronize ：既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是
   synchronized 是属于重量级操作，性能相对更低
3. 加 Sys.out.prient()  todo



### 可见性 vs 原子性

可见性：保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况

原子性：保证线程之间对共享资源读写交互不会出现问题



### 两阶段终止模式

利用停止标记

```java
// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性
// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见

class TPTVolatile {
    private Thread thread;
    private volatile boolean stop = false;
    public void start(){
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if(stop) {
                	log.debug("料理后事");
                	break;
                }
                try {
                	Thread.sleep(1000);
                	log.debug("将结果保存");
                } catch (InterruptedException e){
                }
                // 执行监控操作
            }
        },"监控线程");
        
        thread.start();
   }
    
    public void stop() {
        stop = true;
        thread.interrupt();
    }
}

// 测试
TPTVolatile t = new TPTVolatile();
t.start();
Thread.sleep(3500);
log.debug("stop");
t.stop();
```

**JVM 内存监控**

单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用getInstance）时的线程安全，并思考注释中的问题 **TODO**

> 饿汉式：类加载就会导致该单实例对象被创建
>
> 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建



### 同步模式之 Balking

Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回

```java
public class MonitorService {
	// 用来表示是否已经有线程已经在执行启动了
	private volatile boolean starting; //这里加了synchronized 那么volatile应该不用加
    
    public void start() {
        log.info("尝试启动监控线程...");
        synchronized (this) {
            if (starting) {
            	return;
            }
            starting = true;
        }
        // 真正启动监控线程...
    }
}
```

单例模式

```java
public final class Singleton {
    private Singleton() {
    }
    
    private static Singleton INSTANCE = null;
    
    public static synchronized Singleton getInstance() {
        if (INSTANCE != null) {
        	return INSTANCE;
    	}
        INSTANCE = new Singleton();
        return INSTANCE;
    }
}
```

## 有序性

结果可能是1、4和 **0**

```java

int num = 0;
boolean ready = false;

// 线程1 执行此方法
public void actor1(I_Result r) {
    if(ready) {
   		r.r1 = num + num;
    } else {
    	r.r1 = 1;
    }
}

// 线程2 执行此方法
public void actor2(I_Result r) {
	num = 2;
	ready = true;
}
```

指令重排，是 JIT 编译器在运行时的一些优化

> 借助 java 并发压测工具 jcstress   TODO



解决办法，为 ready 变量加上 volatile 修饰的变量，可以禁用指令重排



### volatile 原理

内存屏障 Memory Barrier（Memory Fence）

- 对 volatile 变量的写指令后会加入写屏障

```java
// 保证在该屏障之前的，对共享变量的改动，都同步到主存当中
public void actor2(I_Result r) {
    num = 2;
    ready = true; // ready 是 volatile 赋值带写屏障
    // 写屏障
}
```

- 对 volatile 变量的读指令前会加入读屏障

```java
// 保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据
public void actor1(I_Result r) {
    // 读屏障
    // ready 是 volatile 读取值带读屏障
    if(ready) {
    	r.r1 = num + num;
    } else {
   		r.r1 = 1;
    }
}
```

> 不能解决指令交错问题
>
> 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去
>
> 而有序性的保证也只是保证了本线程内相关代码不被重排序



### double-checked locking

特点

- 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁
- 第一个 if 使用了 INSTANCE 变量，是在同步块之外

```java
// 有问题 INSTANCE没有全部都包含在同步块内
// INSTANCE = new Singleton()的字节码会分成两步，并且执行的顺序可能被重排序

public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    public static Singleton getInstance() {
        if(INSTANCE == null) { // t2
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                if (INSTANCE == null) { // t1
                    INSTANCE = new Singleton();  //可能其他线程已经先创建了实例，只是没有给INSTANCE赋值，就被切换了，那还是会执行这段代码
            }
            }
        }
        return INSTANCE;
    }
}    
```

> JDK 5 以上的版本的 volatile 才会真正有效

double-checked locking 解决

```java
public final class Singleton {
    private Singleton() { }
    private static volatile Singleton INSTANCE = null;

    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            synchronized (Singleton.class) { // t2
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) { // t1
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

可见性

- 写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中
- 而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据

有序性

- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前



> 更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性  todo

![image-20200925110913723](pic\image-20200925110913723.png)