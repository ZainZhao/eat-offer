### 共享带来的问题

临界区 Critical Section：存在对共享资源多线程读写操作的一段代码块

竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测



**为了避免临界区的竞态条件发生，有多种手段可以达到目的**

阻塞式：synchronized、Lock

非阻塞式：原子变量



同步和互斥的区别：

- 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
- 同步是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点



> Java 中互斥和同步都可以采用 synchronized 关键字来完成



### synchronized

```java
synchronized(对象) // 线程1， 线程2(blocked)
{
	临界区
}
eg..

static int counter = 0;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter++;
            }
        }
    }, "t1");

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter--;
            }
        }
    }, "t2");

    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug("{}",counter);
}

```

<img src="pic\image-20200908090454623.png" alt="image-20200908090454623" style="zoom: 67%;" />

sychronized 实际上是用**对象锁保证了临界区内代码的原子性**，临界区内的代码对外是不可分割的，不会被线程切换所打断

理解

- 如果把 `sychronized(obj)`放在for循环的外面，如何理解？正确，整个for循环变成一个原子操作
- 如果t1 `synchronized(obj1)`而 t1 `synchronized(obj2)`会怎样？无效，对同一个共享变量进行互斥操作，必须要使用相同的对象锁
- 如果t1 `synchronized(obj)` 而t2没有加会怎样？这样与不加锁没什么区别，t2照样可以直接对共享变量进行操作



面向对象改进

```java
// 把互斥的操作放在了类的内部
class Room {
    int value = 0;
    public void increment() {
        synchronized (this) {
            value++;
        }
    }
    public void decrement() {
        synchronized (this) {
        	value--;
        }
    }
    public int get() {
        synchronized (this) { // 获取值也需要枷锁
        	return value;
        }
    }
}

public class Test1 {
    public static void main(String[] args) throws InterruptedException {
    Room room = new Room();
    Thread t1 = new Thread(() -> {
        for (int j = 0; j < 5000; j++) {
       		room.increment();
        }
    }, "t1");
    Thread t2 = new Thread(() -> {
        for (int j = 0; j < 5000; j++) {
        	room.decrement();
        }
    }, "t2");
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug("count: {}" , room.get());
    }
}
```



方法上加的synchronized

```java
class Test{
	public synchronized void test() {

	}
}
// 等价于
class Test{
    public void test() {
        synchronized(this) {
            
        }
    }
}
```



静态方法上加的synchronized

```java
class Test{
	public synchronized static void test() {

	}
}
// 等价于
class Test{
    public static void test() {
        synchronized(this) {
            
        }
    }
}
```



> 线程八锁练习题



### 变量的线程安全分析

成员变量和静态变量是否线程安全？

- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
  - 如果只有读操作，则线程安全
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全



局部变量是否线程安全？

- 局部变量是线程安全的
- 但局部变量引用的对象则未必
  - 如果该对象没有逃离方法的作用访问，它是线程安全的
  - 如果该对象逃离方法的作用范围，需要考虑线程安全，比如用return返回



### 局部变量的线程安全

```java
public static void test1() {
    int i = 10;
    i++;
}
每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享
```

> private修饰符可以保护线程安全吗？
>
> 在一定意义上是可以的，因为他限制了子类不能集成父类的属性或者方法，那么也就防止了父类中的共享变量暴露给子类中的其他线程



**常见的线程安全类**

- String
- 包装类
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的类

> 线程安全类的方法的组合不是线程安全的

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
	table.put("key", value);
}
```

<img src="pic\image-20200911104020683.png" alt="image-20200911104020683" style="zoom:50%;" />



**不可变类是线程安全的**，例如 String