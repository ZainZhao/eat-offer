### 共享带来的问题

临界区 Critical Section：存在对共享资源多线程读写操作的一段代码块

竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测



**为了避免临界区的竞态条件发生，有多种手段可以达到目的**

阻塞式：synchronized、Lock

非阻塞式：原子变量



同步和互斥的区别：

- 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
- 同步是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点



> Java 中互斥和同步都可以采用 synchronized 关键字来完成



### synchronized

```java
synchronized(对象) // 线程1， 线程2(blocked)
{
	临界区
}
eg..

static int counter = 0;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter++;
            }
        }
    }, "t1");

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter--;
            }
        }
    }, "t2");

    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug("{}",counter);
}

```

<img src="pic\image-20200908090454623.png" alt="image-20200908090454623" style="zoom: 67%;" />

sychronized 实际上是用**对象锁保证了临界区内代码的原子性**，临界区内的代码对外是不可分割的，不会被线程切换所打断

理解

- 如果把 `sychronized(obj)`放在for循环的外面，如何理解？正确，整个for循环变成一个原子操作
- 如果t1 `synchronized(obj1)`而 t1 `synchronized(obj2)`会怎样？无效，对同一个共享变量进行互斥操作，必须要使用相同的对象锁
- 如果t1 `synchronized(obj)` 而t2没有加会怎样？这样与不加锁没什么区别，t2照样可以直接对共享变量进行操作



面向对象改进

```java
// 把互斥的操作放在了类的内部
class Room {
    int value = 0;
    public void increment() {
        synchronized (this) {
            value++;
        }
    }
    public void decrement() {
        synchronized (this) {
        	value--;
        }
    }
    public int get() {
        synchronized (this) { // 获取值也需要枷锁
        	return value;
        }
    }
}

public class Test1 {
    public static void main(String[] args) throws InterruptedException {
    Room room = new Room();
    Thread t1 = new Thread(() -> {
        for (int j = 0; j < 5000; j++) {
       		room.increment();
        }
    }, "t1");
    Thread t2 = new Thread(() -> {
        for (int j = 0; j < 5000; j++) {
        	room.decrement();
        }
    }, "t2");
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug("count: {}" , room.get());
    }
}
```



方法上加的synchronized

```java
class Test{
	public synchronized void test() {

	}
}
// 等价于
class Test{
    public void test() {
        synchronized(this) {
            
        }
    }
}
```



静态方法上加的synchronized

```java
class Test{
	public synchronized static void test() {

	}
}
// 等价于
class Test{
    public static void test() {
        synchronized(this) {
            
        }
    }
}
```



> 线程八锁练习题



### 变量的线程安全分析

成员变量和静态变量是否线程安全？

- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
  - 如果只有读操作，则线程安全
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全



局部变量是否线程安全？

- 局部变量是线程安全的
- 但局部变量引用的对象则未必
  - 如果该对象没有逃离方法的作用访问，它是线程安全的
  - 如果该对象逃离方法的作用范围，需要考虑线程安全，比如用return返回



### 局部变量的线程安全

```java
public static void test1() {
    int i = 10;
    i++;
}
每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享
```

> private修饰符可以保护线程安全吗？
>
> 在一定意义上是可以的，因为他限制了子类不能集成父类的属性或者方法，那么也就防止了父类中的共享变量暴露给子类中的其他线程



**常见的线程安全类**

- String
- 包装类
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的类

> 线程安全类的方法的组合不是线程安全的

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
	table.put("key", value);
}
```

<img src="pic\image-20200911104020683.png" alt="image-20200911104020683" style="zoom:50%;" />



**不可变类是线程安全的**，例如 String

**卖票练习**

**转账练习**



### Monitor

**Java 对象头**

以32位虚拟机为例

普通对象

```ruby
|--------------------------------------------------------------|
|                   Object Header (64 bits)                    |
|---------------------------------|----------------------------|
|           Mark Word (32 bits)   |      Klass Word (32 bits)  |
|---------------------------------|----------------------------|
```

数组对象

```ruby
|-----------------------------------------------------------------------------|
|                               Object Header (96 bits)                       |
|----------------------------|-----------------------|------------------------|
|        Mark Word(32bits)   |   Klass Word(32bits)  |  array length(32bits)  |
|----------------------------|-----------------------|------------------------|
```

其中 Mark Word 结构为

```java
|-------------------------------------------------------|--------------------|
| Mark Word (32 bits)                                   |        State       |
|-------------------------------------------------------|--------------------|
|  hashcode:25           | age:4 | biased_lock:0 | 01   |        Normal      |
|-------------------------------------------------------|--------------------|
| thread:23      |epoch:2| age:4 | biased_lock:1 | 01   |        Biased      |
|-------------------------------------------------------|--------------------|
| ptr_to_lock_record:30                          |  00  | Lightweight Locked |
|-------------------------------------------------------|--------------------|
| ptr_to_heavyweight_monitor:30                  |  10  | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                                |  11  |    Marked for GC   |
|-------------------------------------------------------|--------------------|
```

Monitor被翻译为监视器或管程

> 每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针

<img src="pic\image-20200912095953213.png" alt="image-20200912095953213" style="zoom:80%;" />

**sychronized原理**

```java
public static void main(java.lang.String[]);
descriptor: ([Ljava/lang/String;)V
flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
        0: getstatic #2    // <- lock引用 （synchronized开始）
        3: dup
        4: astore_1       // lock引用 -> slot 1
        5: monitorenter   // 将 lock对象 MarkWord 置为 Monitor 指针
        6: getstatic #3   // <- i
        9: iconst_1       // 准备常数 1
        10: iadd          // +1
        11: putstatic #3  // -> i
        14: aload_1       // <- lock引用
        15: monitorexit   // 将 lock对象 MarkWord 重置, 唤醒 EntryList
        16: goto 24
        19: astore_2      // e -> slot 2
        20: aload_1       // <- lock引用
        21: monitorexit   // 将 lock对象 MarkWord 重置, 唤醒 EntryList
        22: aload_2       // <- slot 2 (e)
        23: athrow        // throw e
        24: return
        Exception table:
        from to target type
        6    16    19   any
        19   22    19   any
```



### synchrnized 进阶原理

- 老王 - JVM
  小南 - 线程
  小女 - 线程
  房间 - 对象
  房间门上 - 防盗锁 - Monitor
  房间门上 - 小南书包 - 轻量级锁
  房间门上 - 刻上小南大名 - 偏向锁
  批量重刻名 - 一个类的偏向锁撤销到达 20 阈值
  不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向

小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，即使他离开了，别人也进不了门，他的工作就是安全的。

但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女晚上用。每次上锁太麻烦了，有没有更简单的办法呢？

小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是自己的，那么就在门外等，并通知对方下次用锁门的方式。

后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍然觉得麻烦。

于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦掉，升级为挂书包的方式。

同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字。

后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包

**轻量级锁**

场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以
使用轻量级锁来优化。

语法仍然是 synchronized

```java
static final Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块 A
        method2();
    }
}
public static void method2() {
    synchronized( obj ) {
    	// 同步块 B
    }
}
```

- 创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word

<img src="pic\image-20200912104313692.png" alt="image-20200912104313692" style="zoom: 80%;" />

- 让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录

<img src="pic\image-20200912104423935.png" alt="image-20200912104423935" style="zoom:80%;" />

- 如果 cas 替换成功，对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁

<img src="pic\image-20200912104458328.png" alt="image-20200912104458328" style="zoom:80%;" />

- 如果 cas 失败，有两种情况
  - 如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程
  - 如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数

<img src="pic\image-20200912104644005.png" alt="image-20200912104644005" style="zoom:80%;" />

- 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一
  - 成功，则解锁成功
  - 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程