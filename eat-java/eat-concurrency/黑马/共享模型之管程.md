### 共享带来的问题

临界区 Critical Section：存在对共享资源多线程读写操作的一段代码块

竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测



**为了避免临界区的竞态条件发生，有多种手段可以达到目的**

阻塞式：synchronized、Lock

非阻塞式：原子变量



同步和互斥的区别：

- 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
- 同步是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点



> Java 中互斥和同步都可以采用 synchronized 关键字来完成



### synchronized

```java
synchronized(对象) // 线程1， 线程2(blocked)
{
	临界区
}
eg..

static int counter = 0;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter++;
            }
        }
    }, "t1");

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter--;
            }
        }
    }, "t2");

    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug("{}",counter);
}

```

<img src="pic\image-20200908090454623.png" alt="image-20200908090454623" style="zoom: 67%;" />

sychronized 实际上是用**对象锁保证了临界区内代码的原子性**，临界区内的代码对外是不可分割的，不会被线程切换所打断

理解

- 如果把 `sychronized(obj)`放在for循环的外面，如何理解？正确，整个for循环变成一个原子操作
- 如果t1 `synchronized(obj1)`而 t1 `synchronized(obj2)`会怎样？无效，对同一个共享变量进行互斥操作，必须要使用相同的对象锁
- 如果t1 `synchronized(obj)` 而t2没有加会怎样？这样与不加锁没什么区别，t2照样可以直接对共享变量进行操作